<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title> Final Project </title>
    <meta name="author" content="Adie Present">
    <meta name="description" content="My Final Project">
    <link rel="stylesheet" href="css/styles.css">

  </head>
  <body>

    <!-- <h1> Network </h1> -->
    <!-- <div class="line"></div>
    <div class="line_2"></div> -->


    <!-- <div class="line_d"></div> -->

    <div class="arrow_real"></div>

    <!-- <p> </p>
    <img src="images/arrow.jpg" alt="image"> -->




    <!-- <div class="arrow">
        <img src="images/arrow.jpg" alt=arrowt>
    </div> -->


    <!-- <p>Up arrow: <i class="arrow up"></i></p> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>


    <script>
      var scene = new THREE.Scene();

      var camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000)
      camera.position.z = 10;

      const canvas = document.querySelector('#c');
      var renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setClearColor("#e5e5e5");
      renderer.setSize(window.innerWidth, window.innerHeight);

      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      })

      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();


      var geometry = new THREE.BoxGeometry(.5, .5, .5);
      var material = new THREE.MeshLambertMaterial({color:"#C7005D"});
      var mesh = new THREE.Mesh(geometry, material);
      mesh.name = "cube_center";
      mesh.position.x = .5
      mesh.position.y = .5
      scene.add(mesh);
      // var mesh = new THREE.Mesh(geometry, material);

      // mesh.position.set(-2, 2, 2);
      // mesh.position.y=2;
      // mesh.rotation.set(45,0,0);
      // mesh.scale.set(1,2,1);
      // scene.add(mesh);
      var colors = ["#16CF8E", "#D55490", "#D55490", "#166DCF", "#61166D", "#6516CF"]

      for (var i = 0; i <20; i++) {
        radius = 7;
        width = (radius * 2) + 1;
        height = (radius * 2) + 1;
        angle = (i / (15/2)) * Math.PI;
        var randomColor = Math.floor(Math.random()*colors.length);
        var material_random = new THREE.MeshLambertMaterial({color:colors[randomColor]});
        var mesh = new THREE.Mesh(geometry, material_random);
        mesh.name = "cube_1";
        mesh.myid = i
        // console.log("original x")
        // console.log((radius * Math.cos(angle)) + (width/2) - radius)
        mesh.position.x = (radius * Math.cos(angle)) + (width/2) - radius;
        mesh.position.y = (radius * Math.sin(angle)) + (width/2) - radius;
        mesh.position.z = 0;
        scene.add(mesh);
        // meshx+=1;
      }

      var material_inner_2 = new THREE.MeshLambertMaterial({color:"#69193E"});
      var material_inner = new THREE.MeshLambertMaterial({color:"#D55490"});
      // meshx = -10;
      for (var i = 0; i <15; i++) {
        radius = 5;
        width = (radius * 2) + 1;
        height = (radius * 2) + 1;
        angle = (i / (15/2)) * Math.PI;
        if (i % 2 == 0) {
          var mesh = new THREE.Mesh(geometry, material_inner_2);
          mesh.name = "cube_2";
          mesh.myid = i
          mesh.position.x = (radius * Math.cos(angle)) + (width/2) - radius;
          mesh.position.y = (radius * Math.sin(angle)) + (width/2) - radius;
          mesh.position.z = 0;
          scene.add(mesh);
        }
        else {
          var mesh = new THREE.Mesh(geometry, material_inner);
          mesh.name = "cube_2";
          mesh.myid = i
          mesh.position.x = (radius * Math.cos(angle)) + (width/2) - radius;
          mesh.position.y = (radius * Math.sin(angle)) + (width/2) - radius;
          mesh.position.z = 0;
          scene.add(mesh);
        }

        // meshx+=1;
      }

      var material_inner = new THREE.MeshLambertMaterial({color:"#D55490"});
      for (var i = 0; i <15; i++) {
        radius = 3;
        width = (radius * 2) + 1;
        height = (radius * 2) + 1;
        angle = (i / (15/2)) * Math.PI;
        var mesh = new THREE.Mesh(geometry, material_inner);
        mesh.name = "cube_3";
        mesh.myid = i
        // console.log("original x")
        // console.log((radius * Math.cos(angle)) + (width/2) - radius)
        mesh.position.x = (radius * Math.cos(angle)) + (width/2) - radius;
        mesh.position.y = (radius * Math.sin(angle)) + (width/2) - radius;
        mesh.position.z = 0;
        // mesh.material.color.set("red")
        scene.add(mesh);
        // meshx+=1;
      }



      random_func = () => {
        i = Math.floor(Math.random() * 15) + 1
        console.log(i)
        radius = 6;
        width = (radius * 2) + 1;
        height = (radius * 2) + 1;
        angle = (i / (15/2)) * Math.PI;
        const values = {radius: radius, width: width, height: height, angle: angle};
        return values;
      };




      // var geometry = new THREE.BoxGeometry(1, 1, 1);
      // var material = new THREE.MeshLambertMaterial({color:0xFFCC00});
      // var mesh = new THREE.Mesh(geometry, material);
      // mesh.position.y = 2;
      // scene.add(mesh);


      var light = new THREE.PointLight(0xFFFFFF, 1, 1000)
      light.position.set(0,0,0)
      scene.add(light);

      var light = new THREE.PointLight(0xFFFFFF, 1, 1000)
      light.position.set(0,0,25)
      scene.add(light);

      // doesnt distort objects when screen is refressed
      var render = function() {
        requestAnimationFrame(render);
        scene.traverse(function(mesh) {
          if (mesh.name =="cube_2") {
            mesh.rotation.x += 0.04;
            mesh.rotation.y += 0.04;
          }
          if (mesh.name =="cube_1") {
            mesh.rotation.x += 0.12;
            mesh.rotation.y += 0.12;
          }
          if (mesh.name =="cube_3") {
            mesh.rotation.x += 0.01;
            mesh.rotation.y += 0.01;
          }
          if (mesh.name =="cube_center") {
            mesh.rotation.x += 0.001;
            mesh.rotation.y += 0.001;
          }
        });

        renderer.render(scene, camera);
      }

      function onMouseMove(event) {
        event.preventDefault();
        mouse.x = ( event.clientX / window.innerWidth)  * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        // return array based on where mouse is at in scne
        var intersects = raycaster.intersectObjects(scene.children, true);
        for (var i = 0; i < intersects.length; i++) {
          console.log(intersects[i].object)

          // intersects[i].object.material.color.set(0xff0000)
          this.tl = new TimelineMax();
          this.tl.to(intersects[i].object.scale, 1, {x: 2, ease: Expo.easeOut})
          this.tl.to(intersects[i].object.scale, .5, {x: .5, ease: Expo.easeOut})
          this_func = random_func()
          this.tl.to(intersects[i].object.position, .5, {x: (this_func.radius * Math.cos(this_func.angle)) + (this_func.width/2) - this_func.radius, ease: Expo.easeOut})
          this.tl.to(intersects[i].object.position, .5, {y: (this_func.radius * Math.sin(this_func.angle)) + (this_func.width/2) - this_func.radius, ease: Expo.easeOut}, "=-.5")
          this.tl.to(intersects[i].object.position, .5, {z: 0, ease: Expo.easeOut}, "=-1")
          this.tl.to(intersects[i].object.rotation, .5, {y: Math.Pi*.5, ease: Expo.easeOut}, "=-1.5")
        }
      }

      // function rotation() {
      //   mesh.rotation.y += 0.01;
      //   mesh.rotation.x += 0.01;
      //
      // }


       // re draw render every time screen refreshes
      render();

      const loader = new THREE.TextureLoader();
      const bgTexture = loader.load('images/background2.jpg');
      scene.background = bgTexture;


      // const loader = new THREE.TextureLoader();
      // loader.load('https://images.pexels.com/photos/1205301/pexels-photo-1205301.jpeg' , function(texture)
      //       {
      //        scene.background = texture;
      //       });


      // document.body.addEventListener("click", () => {
      //   this.tl.play();
      // })

      window.addEventListener("click", onMouseMove);
      // window.addEventListener("mousemove", rotation);



    </script>

  </body>
</html>
