<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title> Final Project </title>
    <meta name="author" content="Adie Present">
    <meta name="description" content="My Final Project">
    <link rel="stylesheet" href="css/styles.css">

  </head>
  <body>

    <h1> Network </h1>


    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/102/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.2/TweenMax.min.js"></script>



    <script>
      var scene = new THREE.Scene();

      var camera = new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,0.1,1000)
      camera.position.z = 10;

      var renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setClearColor("#e5e5e5");
      renderer.setSize(window.innerWidth, window.innerHeight);

      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
      })

      var raycaster = new THREE.Raycaster();
      var mouse = new THREE.Vector2();


      var geometry = new THREE.BoxGeometry(1, 1, 1);
      var material = new THREE.MeshLambertMaterial({color:0xF7F7F7});
      // var mesh = new THREE.Mesh(geometry, material);

      // mesh.position.set(-2, 2, 2);
      // mesh.position.y=2;
      // mesh.rotation.set(45,0,0);
      // mesh.scale.set(1,2,1);
      // scene.add(mesh);


      meshx = -10;
      for (var i = 0; i <15; i++) {
        radius = 6;
        width = (radius * 2) + 1;
        height = (radius * 2) + 1;
        angle = (i / (15/2)) * Math.PI;
        var mesh = new THREE.Mesh(geometry, material);
        console.log("original x")
        console.log((radius * Math.cos(angle)) + (width/2) - radius)
        mesh.position.x = (radius * Math.cos(angle)) + (width/2) - radius;
        mesh.position.y = (radius * Math.sin(angle)) + (width/2) - radius;
        mesh.position.z = 0;
        scene.add(mesh);
        meshx+=1;
      }
      // var geometry = new THREE.BoxGeometry(1, 1, 1);
      // var material = new THREE.MeshLambertMaterial({color:0xFFCC00});
      // var mesh = new THREE.Mesh(geometry, material);
      // mesh.position.y = 2;
      // scene.add(mesh);

      arrayX = [];
      for (var i = 0; i<15; i++) {
        radius = 7;
        width = (radius * 2) + 1;
        height = (radius * 2) + 1;
        angle = (i / (15/2)) * Math.PI;
        arrayX.push((radius * Math.cos(angle)) + (width/2) - radius);
      }
      arrayY = [];
      for (var i = 0; i<15; i++) {
        radius = 7;
        width = (radius * 2) + 1;
        height = (radius * 2) + 1;
        angle = (i / (15/2)) * Math.PI;
        arrayX.push((radius * Math.sin(angle)) + (width/2) - radius);
      }
      for (var i = 0; i < arrayX.length; i++) {
        console.log(arrayX[i]);
      }
      Array.min = function( array ){
        return Math.min.apply( Math, array );
      };
      Array.max = function( array ){
        return Math.max.apply( Math, array );
      };
      console.log("min and max:")
      console.log(Array.min(arrayX))
      console.log(Array.max(arrayX))

      var light = new THREE.PointLight(0xFFFFFF, 1, 1000)
      light.position.set(0,0,0)
      scene.add(light);

      var light = new THREE.PointLight(0xFFFFFF, 1, 1000)
      light.position.set(0,0,25)
      scene.add(light);

      // doesnt distort objects when screen is refressed
      var render = function() {
        requestAnimationFrame(render);

        // rotate and sclae and animate while doing so
        // add.01 each time render function is called
        // mesh.rotation.x += 0.01;
        // mesh.rotation.y += 0.01;


        // keep on growing
        // mesh.scale.x -= 0.01;

        renderer.render(scene, camera);
      }

      function onMouseMove(event) {
        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth)  * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);
        // return array based on where mouse is at in scne
        var intersects = raycaster.intersectObjects(scene.children, true);
        for (var i = 0; i < intersects.length; i++) {
          // console.log(intersects[i].object)
          // intersects[i].object.material.color.set(0xff0000)
          this.tl = new TimelineMax();
          this.tl.to(intersects[i].object.scale, 1, {x: 2, ease: Expo.easeOut})
          this.tl.to(intersects[i].object.scale, .5, {x: .5, ease: Expo.easeOut})
          x = arrayX[Math.floor(Math.random()*arrayX.length)];
          console.log("real x")
          console.log(x)
          this.tl.to(intersects[i].object.position, .5, {x: x, ease: Expo.easeOut})
          this.tl.to(intersects[i].object.position, .5, {y: arrayY[Math.floor(Math.random()*arrayY.length)], ease: Expo.easeOut}, "=-.5")
          this.tl.to(intersects[i].object.position, .5, {z: 0, ease: Expo.easeOut}, "=-1")
          this.tl.to(intersects[i].object.rotation, .5, {y: Math.Pi*.5, ease: Expo.easeOut}, "=-1.5")
        }

      }



       // re draw render every time screen refreshes
      render();




      // document.body.addEventListener("click", () => {
      //   this.tl.play();
      // })

      window.addEventListener("mousemove", onMouseMove);
      // window.addEventListener("click", onMouseMove);



    </script>

  </body>
</html>
